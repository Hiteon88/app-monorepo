/*! For license information please see 87209.a089c76cd5.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[87209],{887209:(t,e,r)=>{r.d(e,{secp256k1:()=>F});var n={};r.r(n),r.d(n,{OG:()=>bitMask,My:()=>bytesToHex,bytesToNumberBE:()=>utils_bytesToNumberBE,lX:()=>utils_bytesToNumberLE,Id:()=>utils_concatBytes,fg:()=>createHmacDrbg,qj:()=>utils_ensureBytes,hexToBytes:()=>hexToBytes,lq:()=>utils_numberToBytesBE,z:()=>numberToBytesLE,Q5:()=>validateObject});var i=r(363598),o=r(618507);class SHA2 extends o.Vw{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,o.O8)(this.buffer)}update(t){(0,i.t2)(this);const{view:e,buffer:r,blockLen:n}=this,s=(t=(0,o.ZJ)(t)).length;for(let i=0;i<s;){const a=Math.min(n-this.pos,s-i);if(a!==n)r.set(t.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===n&&(this.process(e,0),this.pos=0);else{const e=(0,o.O8)(t);for(;n<=s-i;i+=n)this.process(e,i)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){(0,i.t2)(this),(0,i.CG)(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:s}=this;let{pos:a}=this;e[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>n-a&&(this.process(r,0),a=0);for(let t=a;t<n;t++)e[t]=0;!function setBigUint64(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(r>>i&o),a=Number(r&o),u=n?4:0,f=n?0:4;t.setUint32(e+u,s,n),t.setUint32(e+f,a,n)}(r,n-8,BigInt(8*this.length),s),this.process(r,0);const u=(0,o.O8)(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=f/4,l=this.get();if(c>l.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<c;t++)u.setUint32(4*t,l[t],s)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:i,destroyed:o,pos:s}=this;return t.length=n,t.pos=s,t.finished=i,t.destroyed=o,n%e&&t.buffer.set(r),t}}const Maj=(t,e,r)=>t&e^t&r^e&r,s=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),a=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),u=new Uint32Array(64);class SHA256 extends SHA2{constructor(){super(64,32,8,!1),this.A=0|a[0],this.B=0|a[1],this.C=0|a[2],this.D=0|a[3],this.E=0|a[4],this.F=0|a[5],this.G=0|a[6],this.H=0|a[7]}get(){const{A:t,B:e,C:r,D:n,E:i,F:o,G:s,H:a}=this;return[t,e,r,n,i,o,s,a]}set(t,e,r,n,i,o,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)u[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=u[t-15],r=u[t-2],n=(0,o.Ow)(e,7)^(0,o.Ow)(e,18)^e>>>3,i=(0,o.Ow)(r,17)^(0,o.Ow)(r,19)^r>>>10;u[t]=i+u[t-7]+n+u[t-16]|0}let{A:r,B:n,C:i,D:a,E:f,F:c,G:l,H:d}=this;for(let t=0;t<64;t++){const e=d+((0,o.Ow)(f,6)^(0,o.Ow)(f,11)^(0,o.Ow)(f,25))+((g=f)&c^~g&l)+s[t]+u[t]|0,w=((0,o.Ow)(r,2)^(0,o.Ow)(r,13)^(0,o.Ow)(r,22))+Maj(r,n,i)|0;d=l,l=c,c=f,f=a+e|0,a=i,i=n,n=r,r=e+w|0}var g;r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,a=a+this.D|0,f=f+this.E|0,c=c+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(r,n,i,a,f,c,l,d)}roundClean(){u.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const f=(0,o.ld)((()=>new SHA256)),c=(BigInt(0),BigInt(1)),l=BigInt(2),u8a=t=>t instanceof Uint8Array,d=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function bytesToHex(t){if(!u8a(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=d[t[r]];return e}function hexToNumber(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}function hexToBytes(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(e/2);for(let e=0;e<r.length;e++){const n=2*e,i=t.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");r[e]=o}return r}function utils_bytesToNumberBE(t){return hexToNumber(bytesToHex(t))}function utils_bytesToNumberLE(t){if(!u8a(t))throw new Error("Uint8Array expected");return hexToNumber(bytesToHex(Uint8Array.from(t).reverse()))}function utils_numberToBytesBE(t,e){return hexToBytes(t.toString(16).padStart(2*e,"0"))}function numberToBytesLE(t,e){return utils_numberToBytesBE(t,e).reverse()}function utils_ensureBytes(t,e,r){let n;if("string"==typeof e)try{n=hexToBytes(e)}catch(r){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else{if(!u8a(e))throw new Error(`${t} must be hex string or Uint8Array`);n=Uint8Array.from(e)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(`${t} expected ${r} bytes, got ${i}`);return n}function utils_concatBytes(...t){const e=new Uint8Array(t.reduce(((t,e)=>t+e.length),0));let r=0;return t.forEach((t=>{if(!u8a(t))throw new Error("Uint8Array expected");e.set(t,r),r+=t.length})),e}const bitMask=t=>(l<<BigInt(t-1))-c,u8n=t=>new Uint8Array(t),u8fr=t=>Uint8Array.from(t);function createHmacDrbg(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=u8n(t),i=u8n(t),o=0;const reset=()=>{n.fill(1),i.fill(0),o=0},h=(...t)=>r(i,n,...t),reseed=(t=u8n())=>{i=h(u8fr([0]),t),n=h(),0!==t.length&&(i=h(u8fr([1]),t),n=h())},gen=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=h();const e=n.slice();r.push(e),t+=n.length}return utils_concatBytes(...r)};return(t,e)=>{let r;for(reset(),reseed(t);!(r=e(gen()));)reseed();return reset(),r}}const g={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function validateObject(t,e,r={}){const checkField=(e,r,n)=>{const i=g[r];if("function"!=typeof i)throw new Error(`Invalid validator "${r}", expected function`);const o=t[e];if(!(n&&void 0===o||i(o,t)))throw new Error(`Invalid param ${String(e)}=${o} (${typeof o}), expected ${r}`)};for(const[t,r]of Object.entries(e))checkField(t,r,!1);for(const[t,e]of Object.entries(r))checkField(t,e,!0);return t}const w=BigInt(0),y=BigInt(1),p=BigInt(2),m=BigInt(3),b=BigInt(4),E=BigInt(5),B=BigInt(8);BigInt(9),BigInt(16);function modular_mod(t,e){const r=t%e;return r>=w?r:e+r}function pow(t,e,r){if(r<=w||e<w)throw new Error("Expected power/modulo > 0");if(r===y)return w;let n=y;for(;e>w;)e&y&&(n=n*t%r),t=t*t%r,e>>=y;return n}function pow2(t,e,r){let n=t;for(;e-- >w;)n*=n,n%=r;return n}function invert(t,e){if(t===w||e<=w)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=modular_mod(t,e),n=e,i=w,o=y,s=y,a=w;for(;r!==w;){const t=n/r,e=n%r,u=i-s*t,f=o-a*t;n=r,r=e,i=s,o=a,s=u,a=f}if(n!==y)throw new Error("invert: does not exist");return modular_mod(i,e)}function FpSqrt(t){if(t%b===m){const e=(t+y)/b;return function sqrt3mod4(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}if(t%B===E){const e=(t-E)/B;return function sqrt5mod8(t,r){const n=t.mul(r,p),i=t.pow(n,e),o=t.mul(r,i),s=t.mul(t.mul(o,p),i),a=t.mul(o,t.sub(s,t.ONE));if(!t.eql(t.sqr(a),r))throw new Error("Cannot find square root");return a}}return function tonelliShanks(t){const e=(t-y)/p;let r,n,i;for(r=t-y,n=0;r%p===w;r/=p,n++);for(i=p;i<t&&pow(i,e,t)!==t-y;i++);if(1===n){const e=(t+y)/b;return function tonelliFast(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}const o=(r+y)/p;return function tonelliSlow(t,s){if(t.pow(s,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let a=n,u=t.pow(t.mul(t.ONE,i),r),f=t.pow(s,o),c=t.pow(s,r);for(;!t.eql(c,t.ONE);){if(t.eql(c,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(c);e<a&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(u,y<<BigInt(a-e-1));u=t.sqr(r),f=t.mul(f,r),c=t.mul(c,u),a=e}return f}}(t)}const v=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function nLength(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function getFieldBytesLength(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function getMinHashLength(t){const e=getFieldBytesLength(t);return e+Math.ceil(e/2)}class HMAC extends o.Vw{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,i.tW)(t);const r=(0,o.ZJ)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?t.create().update(r).digest():r);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){return(0,i.t2)(this),this.iHash.update(t),this}digestInto(t){(0,i.t2)(this),(0,i.ee)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:i,blockLen:o,outputLen:s}=this;return t.finished=n,t.destroyed=i,t.blockLen=o,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(t,e,r)=>new HMAC(t,e).update(r).digest();hmac.create=(t,e)=>new HMAC(t,e);const x=BigInt(0),S=BigInt(1);function validateBasic(t){return function validateField(t){return validateObject(t,v.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"}))}(t.Fp),validateObject(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}const{bytesToNumberBE:I,hexToBytes:O}=n,A={Err:class DERErr extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=A;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const r=t[1],n=t.subarray(2,r+2);if(!r||n.length!==r)throw new e("Invalid signature integer: wrong length");if(128&n[0])throw new e("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:I(n),l:t.subarray(r+2)}},toSig(t){const{Err:e}=A,r="string"==typeof t?O(t):t;if(!(r instanceof Uint8Array))throw new Error("ui8a expected");let n=r.length;if(n<2||48!=r[0])throw new e("Invalid signature tag");if(r[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:i,l:o}=A._parseInt(r.subarray(2)),{d:s,l:a}=A._parseInt(o);if(a.length)throw new e("Invalid signature: left bytes after parsing");return{r:i,s}},hexFromSig(t){const slice=t=>8&Number.parseInt(t[0],16)?"00"+t:t,h=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},e=slice(h(t.s)),r=slice(h(t.r)),n=e.length/2,i=r.length/2,o=h(n),s=h(i);return`30${h(i+n+4)}02${s}${r}02${o}${e}`}},N=BigInt(0),P=BigInt(1),T=(BigInt(2),BigInt(3));BigInt(4);function weierstrassPoints(t){const e=function validatePointOpts(t){const e=validateBasic(t);validateObject(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:i}=e;if(r){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,n=e.toBytes||((t,e,n)=>{const i=e.toAffine();return utils_concatBytes(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),i=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function weierstrassEquation(t){const{a:n,b:i}=e,o=r.sqr(t),s=r.mul(o,t);return r.add(r.add(s,r.mul(t,n)),i)}if(!r.eql(r.sqr(e.Gy),weierstrassEquation(e.Gx)))throw new Error("bad generator point: equation left != right");function isWithinCurveOrder(t){return"bigint"==typeof t&&N<t&&t<e.n}function assertGE(t){if(!isWithinCurveOrder(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function normPrivateKeyToScalar(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:o}=e;if(r&&"bigint"!=typeof t){if(t instanceof Uint8Array&&(t=bytesToHex(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*n,"0")}let s;try{s="bigint"==typeof t?t:utils_bytesToNumberBE(utils_ensureBytes("private key",t,n))}catch(e){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof t}`)}return i&&(s=modular_mod(s,o)),assertGE(s),s}const o=new Map;function assertPrjPoint(t){if(!(t instanceof Point))throw new Error("ProjectivePoint expected")}class Point{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof Point)throw new Error("projective point not allowed");const is0=t=>r.eql(t,r.ZERO);return is0(e)&&is0(n)?Point.ZERO:new Point(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(Point.fromAffine)}static fromHex(t){const e=Point.fromAffine(i(utils_ensureBytes("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return Point.BASE.multiply(normPrivateKeyToScalar(t))}_setWindowSize(t){this._WINDOW_SIZE=t,o.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:n}=this.toAffine();if(!r.isValid(t)||!r.isValid(n))throw new Error("bad point: x or y not FE");const i=r.sqr(n),o=weierstrassEquation(t);if(!r.eql(i,o))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){assertPrjPoint(t);const{px:e,py:n,pz:i}=this,{px:o,py:s,pz:a}=t,u=r.eql(r.mul(e,a),r.mul(o,i)),f=r.eql(r.mul(n,a),r.mul(s,i));return u&&f}negate(){return new Point(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,i=r.mul(n,T),{px:o,py:s,pz:a}=this;let u=r.ZERO,f=r.ZERO,c=r.ZERO,l=r.mul(o,o),d=r.mul(s,s),g=r.mul(a,a),w=r.mul(o,s);return w=r.add(w,w),c=r.mul(o,a),c=r.add(c,c),u=r.mul(t,c),f=r.mul(i,g),f=r.add(u,f),u=r.sub(d,f),f=r.add(d,f),f=r.mul(u,f),u=r.mul(w,u),c=r.mul(i,c),g=r.mul(t,g),w=r.sub(l,g),w=r.mul(t,w),w=r.add(w,c),c=r.add(l,l),l=r.add(c,l),l=r.add(l,g),l=r.mul(l,w),f=r.add(f,l),g=r.mul(s,a),g=r.add(g,g),l=r.mul(g,w),u=r.sub(u,l),c=r.mul(g,d),c=r.add(c,c),c=r.add(c,c),new Point(u,f,c)}add(t){assertPrjPoint(t);const{px:n,py:i,pz:o}=this,{px:s,py:a,pz:u}=t;let f=r.ZERO,c=r.ZERO,l=r.ZERO;const d=e.a,g=r.mul(e.b,T);let w=r.mul(n,s),y=r.mul(i,a),p=r.mul(o,u),m=r.add(n,i),b=r.add(s,a);m=r.mul(m,b),b=r.add(w,y),m=r.sub(m,b),b=r.add(n,o);let E=r.add(s,u);return b=r.mul(b,E),E=r.add(w,p),b=r.sub(b,E),E=r.add(i,o),f=r.add(a,u),E=r.mul(E,f),f=r.add(y,p),E=r.sub(E,f),l=r.mul(d,b),f=r.mul(g,p),l=r.add(f,l),f=r.sub(y,l),l=r.add(y,l),c=r.mul(f,l),y=r.add(w,w),y=r.add(y,w),p=r.mul(d,p),b=r.mul(g,b),y=r.add(y,p),p=r.sub(w,p),p=r.mul(d,p),b=r.add(b,p),w=r.mul(y,b),c=r.add(c,w),w=r.mul(E,b),f=r.mul(m,f),f=r.sub(f,w),w=r.mul(m,y),l=r.mul(E,l),l=r.add(l,w),new Point(f,c,l)}subtract(t){return this.add(t.negate())}is0(){return this.equals(Point.ZERO)}wNAF(t){return a.wNAFCached(this,o,t,(t=>{const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(Point.fromAffine)}))}multiplyUnsafe(t){const n=Point.ZERO;if(t===N)return n;if(assertGE(t),t===P)return this;const{endo:i}=e;if(!i)return a.unsafeLadder(this,t);let{k1neg:o,k1:s,k2neg:u,k2:f}=i.splitScalar(t),c=n,l=n,d=this;for(;s>N||f>N;)s&P&&(c=c.add(d)),f&P&&(l=l.add(d)),d=d.double(),s>>=P,f>>=P;return o&&(c=c.negate()),u&&(l=l.negate()),l=new Point(r.mul(l.px,i.beta),l.py,l.pz),c.add(l)}multiply(t){assertGE(t);let n,i,o=t;const{endo:s}=e;if(s){const{k1neg:t,k1:e,k2neg:u,k2:f}=s.splitScalar(o);let{p:c,f:l}=this.wNAF(e),{p:d,f:g}=this.wNAF(f);c=a.constTimeNegate(t,c),d=a.constTimeNegate(u,d),d=new Point(r.mul(d.px,s.beta),d.py,d.pz),n=c.add(d),i=l.add(g)}else{const{p:t,f:e}=this.wNAF(o);n=t,i=e}return Point.normalizeZ([n,i])[0]}multiplyAndAddUnsafe(t,e,r){const n=Point.BASE,mul=(t,e)=>e!==N&&e!==P&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),i=mul(this,e).add(mul(t,r));return i.is0()?void 0:i}toAffine(t){const{px:e,py:n,pz:i}=this,o=this.is0();null==t&&(t=o?r.ONE:r.inv(i));const s=r.mul(e,t),a=r.mul(n,t),u=r.mul(i,t);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(u,r.ONE))throw new Error("invZ was invalid");return{x:s,y:a}}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===P)return!0;if(r)return r(Point,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===P?this:r?r(Point,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),n(Point,this,t)}toHex(t=!0){return bytesToHex(this.toRawBytes(t))}}Point.BASE=new Point(e.Gx,e.Gy,r.ONE),Point.ZERO=new Point(r.ZERO,r.ONE,r.ZERO);const s=e.nBitLength,a=function wNAF(t,e){const constTimeNegate=(t,e)=>{const r=e.negate();return t?r:e},opts=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate,unsafeLadder(e,r){let n=t.ZERO,i=e;for(;r>x;)r&S&&(n=n.add(i)),i=i.double(),r>>=S;return n},precomputeWindow(t,e){const{windows:r,windowSize:n}=opts(e),i=[];let o=t,s=o;for(let t=0;t<r;t++){s=o,i.push(s);for(let t=1;t<n;t++)s=s.add(o),i.push(s);o=s.double()}return i},wNAF(e,r,n){const{windows:i,windowSize:o}=opts(e);let s=t.ZERO,a=t.BASE;const u=BigInt(2**e-1),f=2**e,c=BigInt(e);for(let t=0;t<i;t++){const e=t*o;let i=Number(n&u);n>>=c,i>o&&(i-=f,n+=S);const l=e,d=e+Math.abs(i)-1,g=t%2!=0,w=i<0;0===i?a=a.add(constTimeNegate(g,r[l])):s=s.add(constTimeNegate(w,r[d]))}return{p:s,f:a}},wNAFCached(t,e,r,n){const i=t._WINDOW_SIZE||1;let o=e.get(t);return o||(o=this.precomputeWindow(t,i),1!==i&&e.set(t,n(o))),this.wNAF(i,o,r)}}}(Point,e.endo?Math.ceil(s/2):s);return{CURVE:e,ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}}function weierstrass(t){const e=function validateOpts(t){const e=validateBasic(t);return validateObject(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n}=e,i=r.BYTES+1,o=2*r.BYTES+1;function modN(t){return modular_mod(t,n)}function invN(t){return invert(t,n)}const{ProjectivePoint:s,normPrivateKeyToScalar:a,weierstrassEquation:u,isWithinCurveOrder:f}=weierstrassPoints({...e,toBytes(t,e,n){const i=e.toAffine(),o=r.toBytes(i.x),s=utils_concatBytes;return n?s(Uint8Array.from([e.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,r.toBytes(i.y))},fromBytes(t){const e=t.length,n=t[0],s=t.subarray(1);if(e!==i||2!==n&&3!==n){if(e===o&&4===n){return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${e} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}{const t=utils_bytesToNumberBE(s);if(!function isValidFieldElement(t){return N<t&&t<r.ORDER}(t))throw new Error("Point is not on curve");const e=u(t);let i=r.sqrt(e);return!(1&~n)!==((i&P)===P)&&(i=r.neg(i)),{x:t,y:i}}}}),numToNByteStr=t=>bytesToHex(utils_numberToBytesBE(t,e.nByteLength));function isBiggerThanHalfOrder(t){return t>n>>P}const slcNum=(t,e,r)=>utils_bytesToNumberBE(t.slice(e,r));class Signature{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const r=e.nByteLength;return t=utils_ensureBytes("compactSignature",t,2*r),new Signature(slcNum(t,0,r),slcNum(t,r,2*r))}static fromDER(t){const{r:e,s:r}=A.toSig(utils_ensureBytes("DER",t));return new Signature(e,r)}assertValidity(){if(!f(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!f(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new Signature(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:i,recovery:o}=this,a=d(utils_ensureBytes("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const u=2===o||3===o?n+e.n:n;if(u>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const f=1&o?"03":"02",c=s.fromHex(f+numToNByteStr(u)),l=invN(u),g=modN(-a*l),w=modN(i*l),y=s.BASE.multiplyAndAddUnsafe(c,g,w);if(!y)throw new Error("point at infinify");return y.assertValidity(),y}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){return A.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const c={isValidPrivateKey(t){try{return a(t),!0}catch(t){return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{const t=getMinHashLength(e.n);return function mapHashToField(t,e,r=!1){const n=t.length,i=getFieldBytesLength(e),o=getMinHashLength(e);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const s=modular_mod(r?utils_bytesToNumberBE(t):utils_bytesToNumberLE(t),e-y)+y;return r?numberToBytesLE(s,i):utils_numberToBytesBE(s,i)}(e.randomBytes(t),e.n)},precompute:(t=8,e=s.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function isProbPub(t){const e=t instanceof Uint8Array,r="string"==typeof t,n=(e||r)&&t.length;return e?n===i||n===o:r?n===2*i||n===2*o:t instanceof s}const l=e.bits2int||function(t){const r=utils_bytesToNumberBE(t),n=8*t.length-e.nBitLength;return n>0?r>>BigInt(n):r},d=e.bits2int_modN||function(t){return modN(l(t))},g=bitMask(e.nBitLength);function int2octets(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(N<=t&&t<g))throw new Error(`bigint expected < 2^${e.nBitLength}`);return utils_numberToBytesBE(t,e.nByteLength)}function prepSig(t,n,i=w){if(["recovered","canonical"].some((t=>t in i)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:u}=e;let{lowS:c,prehash:g,extraEntropy:y}=i;null==c&&(c=!0),t=utils_ensureBytes("msgHash",t),g&&(t=utils_ensureBytes("prehashed msgHash",o(t)));const p=d(t),m=a(n),b=[int2octets(m),int2octets(p)];if(null!=y){const t=!0===y?u(r.BYTES):y;b.push(utils_ensureBytes("extraEntropy",t))}const E=utils_concatBytes(...b),B=p;return{seed:E,k2sig:function k2sig(t){const e=l(t);if(!f(e))return;const r=invN(e),n=s.BASE.multiply(e).toAffine(),i=modN(n.x);if(i===N)return;const o=modN(r*modN(B+i*m));if(o===N)return;let a=(n.x===i?0:2)|Number(n.y&P),u=o;return c&&isBiggerThanHalfOrder(o)&&(u=function normalizeS(t){return isBiggerThanHalfOrder(t)?modN(-t):t}(o),a^=1),new Signature(i,u,a)}}}const w={lowS:e.lowS,prehash:!1},p={lowS:e.lowS,prehash:!1};return s.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function getPublicKey(t,e=!0){return s.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function getSharedSecret(t,e,r=!0){if(isProbPub(t))throw new Error("first arg must be private key");if(!isProbPub(e))throw new Error("second arg must be public key");return s.fromHex(e).multiply(a(t)).toRawBytes(r)},sign:function sign(t,r,n=w){const{seed:i,k2sig:o}=prepSig(t,r,n),s=e;return createHmacDrbg(s.hash.outputLen,s.nByteLength,s.hmac)(i,o)},verify:function verify(t,r,n,i=p){const o=t;if(r=utils_ensureBytes("msgHash",r),n=utils_ensureBytes("publicKey",n),"strict"in i)throw new Error("options.strict was renamed to lowS");const{lowS:a,prehash:u}=i;let f,c;try{if("string"==typeof o||o instanceof Uint8Array)try{f=Signature.fromDER(o)}catch(t){if(!(t instanceof A.Err))throw t;f=Signature.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw new Error("PARSE");{const{r:t,s:e}=o;f=new Signature(t,e)}}c=s.fromHex(n)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(a&&f.hasHighS())return!1;u&&(r=e.hash(r));const{r:l,s:g}=f,w=d(r),y=invN(g),m=modN(w*y),b=modN(l*y),E=s.BASE.multiplyAndAddUnsafe(c,m,b)?.toAffine();return!!E&&modN(E.x)===l},ProjectivePoint:s,Signature,utils:c}}function getHash(t){return{hash:t,hmac:(e,...r)=>hmac(t,e,(0,o.Id)(...r)),randomBytes:o.po}}const H=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),_=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),q=BigInt(1),L=BigInt(2),divNearest=(t,e)=>(t+e/L)/e;function sqrtMod(t){const e=H,r=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),u=BigInt(88),f=t*t*t%e,c=f*f*t%e,l=pow2(c,r,e)*c%e,d=pow2(l,r,e)*c%e,g=pow2(d,L,e)*f%e,w=pow2(g,i,e)*g%e,y=pow2(w,o,e)*w%e,p=pow2(y,a,e)*y%e,m=pow2(p,u,e)*p%e,b=pow2(m,a,e)*y%e,E=pow2(b,r,e)*c%e,B=pow2(E,s,e)*w%e,v=pow2(B,n,e)*f%e,x=pow2(v,L,e);if(!R.eql(R.sqr(x),t))throw new Error("Cannot find square root");return x}const R=function Field(t,e,r=!1,n={}){if(t<=w)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:i,nByteLength:o}=nLength(t,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=FpSqrt(t),a=Object.freeze({ORDER:t,BITS:i,BYTES:o,MASK:bitMask(i),ZERO:w,ONE:y,create:e=>modular_mod(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return w<=e&&e<t},is0:t=>t===w,isOdd:t=>(t&y)===y,neg:e=>modular_mod(-e,t),eql:(t,e)=>t===e,sqr:e=>modular_mod(e*e,t),add:(e,r)=>modular_mod(e+r,t),sub:(e,r)=>modular_mod(e-r,t),mul:(e,r)=>modular_mod(e*r,t),pow:(t,e)=>function FpPow(t,e,r){if(r<w)throw new Error("Expected power > 0");if(r===w)return t.ONE;if(r===y)return e;let n=t.ONE,i=e;for(;r>w;)r&y&&(n=t.mul(n,i)),i=t.sqr(i),r>>=y;return n}(a,t,e),div:(e,r)=>modular_mod(e*invert(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>invert(e,t),sqrt:n.sqrt||(t=>s(a,t)),invertBatch:t=>function FpInvertBatch(t,e){const r=new Array(e.length),n=e.reduce(((e,n,i)=>t.is0(n)?e:(r[i]=e,t.mul(e,n))),t.ONE),i=t.inv(n);return e.reduceRight(((e,n,i)=>t.is0(n)?e:(r[i]=t.mul(e,r[i]),t.mul(e,n))),i),r}(a,t),cmov:(t,e,r)=>r?e:t,toBytes:t=>r?numberToBytesLE(t,o):utils_numberToBytesBE(t,o),fromBytes:t=>{if(t.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${t.length}`);return r?utils_bytesToNumberLE(t):utils_bytesToNumberBE(t)}});return Object.freeze(a)}(H,void 0,void 0,{sqrt:sqrtMod}),F=function createCurve(t,e){const create=e=>weierstrass({...t,...getHash(e)});return Object.freeze({...create(e),create})}({a:BigInt(0),b:BigInt(7),Fp:R,n:_,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=_,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-q*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,s=BigInt("0x100000000000000000000000000000000"),a=divNearest(o*t,e),u=divNearest(-n*t,e);let f=modular_mod(t-a*r-u*i,e),c=modular_mod(-a*n-u*o,e);const l=f>s,d=c>s;if(l&&(f=e-f),d&&(c=e-c),f>s||c>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:f,k2neg:d,k2:c}}}},f);BigInt(0);F.ProjectivePoint}}]);