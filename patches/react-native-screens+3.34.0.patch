diff --git a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt
index cf44d7d..fb253f7 100644
--- a/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt
+++ b/node_modules/react-native-screens/android/src/main/java/com/swmansion/rnscreens/ScreenContainer.kt
@@ -2,6 +2,7 @@ package com.swmansion.rnscreens
 
 import android.content.Context
 import android.content.ContextWrapper
+import android.view.MotionEvent
 import android.view.View
 import android.view.ViewGroup
 import android.view.ViewParent
@@ -14,6 +15,7 @@ import com.facebook.react.ReactRootView
 import com.facebook.react.bridge.ReactContext
 import com.facebook.react.modules.core.ChoreographerCompat
 import com.facebook.react.modules.core.ReactChoreographer
+import com.facebook.react.views.view.ReactViewGroup
 import com.facebook.react.uimanager.ThemedReactContext
 import com.facebook.react.uimanager.UIManagerHelper
 import com.swmansion.rnscreens.Screen.ActivityState
@@ -42,6 +44,7 @@ open class ScreenContainer(
             }
         }
     private var parentScreenWrapper: ScreenFragmentWrapper? = null
+    private var shouldBreakJSUpdateCount = 0;
 
     override fun onLayout(
         changed: Boolean,
@@ -54,7 +57,7 @@ open class ScreenContainer(
         val size = childCount
         while (i < size) {
             getChildAt(i).layout(0, 0, width, height)
-            i++
+            i
         }
     }
 
@@ -260,6 +263,55 @@ open class ScreenContainer(
         super.onAttachedToWindow()
         isAttached = true
         setupFragmentManager()
+        parentScreenWrapper.find { it.screen.activityState == ActivityState.ON_TOP }
+                ?: return
+        
+        val parentView = parent as? ViewGroup
+        if (parentView == null || parentView.childCount != 2) {
+           return
+       }
+
+       val tabBar = (parentView.getChildAt(1) as? ViewGroup)?.getChildAt(0) as? ViewGroup ?: return
+
+       for (index in 0 until tabBar.childCount) {
+           val tabBarItem = tabBar.getChildAt(index) as? ReactViewGroup ?: return
+
+           tabBarItem.setOnInterceptTouchEventListener { viewGroup, motionEvent ->
+               if (motionEvent.action != MotionEvent.ACTION_UP) {
+                   return@setOnInterceptTouchEventListener false
+               }
+               if (parentScreenWrapper[index].screen.activityState == ActivityState.ON_TOP) {
+                   return@setOnInterceptTouchEventListener false
+               }
+               parentScreenWrapper.forEach {
+                   it.screen.setActivityState(ActivityState.INACTIVE)
+               }
+               parentScreenWrapper[index].screen.setActivityState(ActivityState.ON_TOP)
+
+               for (itemIndex in 0 until tabBar.childCount) {
+                   var item = tabBar.getChildAt(itemIndex) as? ViewGroup
+                   if (item == null || item.childCount != 2) {
+                       item = (tabBar.getChildAt(itemIndex) as? ViewGroup)?.getChildAt(0) as? ViewGroup
+                       if (item == null || item.childCount != 2) {
+                           continue
+                       }
+                   }
+                   var aboveView = item.getChildAt(0) as? ReactViewGroup
+                   var belowView = item.getChildAt(1) as? ReactViewGroup
+                   if (((aboveView?.alpha ?: 0f) (belowView?.alpha ?: 0f)) != 1.0f) {
+                       continue
+                   }
+                   aboveView?.setOpacityIfPossible(if (itemIndex == index) 0f else 1f)
+                   belowView?.setOpacityIfPossible(if (itemIndex == index) 1f else 0f)
+               }
+               shouldBreakJSUpdateCount = 1;
+               createTransaction().let {
+                   topScreen?.fragment?.let { fragment -> detachScreen(it, fragment) }
+                   attachScreen(it, parentScreenWrapper[index].fragment)
+               }
+               true
+           }
+       }
     }
 
     /** Removes fragments from fragment manager that are attached to this container  */
diff --git a/node_modules/react-native-screens/common/cpp/react/renderer/components/rnscreens/RNSScreenComponentDescriptor.h b/node_modules/react-native-screens/common/cpp/react/renderer/components/rnscreens/RNSScreenComponentDescriptor.h
index 37aac4e..5fb5505 100644
--- a/node_modules/react-native-screens/common/cpp/react/renderer/components/rnscreens/RNSScreenComponentDescriptor.h
+++ b/node_modules/react-native-screens/common/cpp/react/renderer/components/rnscreens/RNSScreenComponentDescriptor.h
@@ -6,8 +6,8 @@
 #include <react/debug/react_native_assert.h>
 #include <react/renderer/components/rnscreens/Props.h>
 #include <react/renderer/core/ConcreteComponentDescriptor.h>
+#include <react/renderer/components/rnscreens/utils/RectUtil.h>
 #include "RNSScreenShadowNode.h"
-#include "utils/RectUtil.h"
 
 namespace facebook {
 namespace react {
diff --git a/node_modules/react-native-screens/ios/RNSFullWindowOverlay.mm b/node_modules/react-native-screens/ios/RNSFullWindowOverlay.mm
index ca1278a..e447f7d 100644
--- a/node_modules/react-native-screens/ios/RNSFullWindowOverlay.mm
+++ b/node_modules/react-native-screens/ios/RNSFullWindowOverlay.mm
@@ -33,6 +33,29 @@ - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event
   return NO;
 }
 
+// Here is just copied from UIViewReact, but we have modified `self.reactSubviews` to `self.subviews`
+// because `RNSFullWindowOverlayContainer` is just a simple UIView without the `reactSubviews` property.
+- (NSArray<UIView *> *)reactZIndexSortedSubviews
+{
+  // Check if sorting is required - in most cases it won't be.
+  BOOL sortingRequired = NO;
+  for (UIView *subview in self.subviews) {
+    if (subview.reactZIndex != 0) {
+      sortingRequired = YES;
+      break;
+    }
+  }
+  return sortingRequired ? [self.subviews sortedArrayUsingComparator:^NSComparisonResult(UIView *a, UIView *b) {
+    if (a.reactZIndex > b.reactZIndex) {
+      return NSOrderedDescending;
+    } else {
+      // Ensure sorting is stable by treating equal zIndex as ascending so
+      // that original order is preserved.
+      return NSOrderedAscending;
+    }
+  }] : self.subviews;
+}
+
 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
 {
   BOOL canReceiveTouchEvents = ([self isUserInteractionEnabled] && ![self isHidden]);
@@ -162,7 +185,7 @@ - (void)maybeShow
   }
 }
 
-+ (react::ComponentDescriptorProvider)componentDescriptorProvider
+ (react::ComponentDescriptorProvider)componentDescriptorProvider
 {
   return react::concreteComponentDescriptorProvider<react::RNSFullWindowOverlayComponentDescriptor>();
 }
diff --git a/node_modules/react-native-screens/ios/RNSScreen.mm b/node_modules/react-native-screens/ios/RNSScreen.mm
index b673407..67d89af 100644
--- a/node_modules/react-native-screens/ios/RNSScreen.mm
+++ b/node_modules/react-native-screens/ios/RNSScreen.mm
@@ -2,6 +2,7 @@
 
 #import "RNSScreen.h"
 #import "RNSScreenContainer.h"
+#import "RNSScreenNavigationContainer.h"
 #import "RNSScreenWindowTraits.h"
 
 #ifdef RCT_NEW_ARCH_ENABLED
@@ -25,7 +26,7 @@
 #import "RNSScreenStack.h"
 #import "RNSScreenStackHeaderConfig.h"
 
-#import "UIView+RNSUtility.h"
+#import "UIViewRNSUtility.h"
 
 #ifdef RCT_NEW_ARCH_ENABLED
 namespace react = facebook::react;
@@ -456,8 +457,87 @@ - (BOOL)isMountedUnderScreenOrReactRoot
 #undef RNS_EXPECTED_VIEW
 }
 
+- (void)addGestureToTabBarItem {
+  UIView *superview = self.superview.superview.superview.superview.superview;
+  if (superview.subviews.count == 2) {
+    UIView *tabBarView = [[superview.subviews[1] subviews] firstObject];
+    for (UIView *view in tabBarView.subviews) {
+      for (UIGestureRecognizer *gestureRecognizer in view.gestureRecognizers) {
+        [view removeGestureRecognizer:gestureRecognizer];
+      }
+      UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(switchTabFromGesture:)];
+      [view addGestureRecognizer:tapGestureRecognizer];
+    }
+  }
+}
+
+- (void)switchTabFromGesture:(UITapGestureRecognizer *)gesture {
+  NSInteger index = [gesture.view.superview.subviews indexOfObject:gesture.view];
+  if (index == NSNotFound) {
+    return;
+  }
+
+  id _containerView = [gesture.view.superview.superview.superview.subviews firstObject];
+  if (![_containerView isKindOfClass:[RNSScreenNavigationContainerView class]]) {
+    return;
+  }
+  RNSScreenNavigationContainerView *containerView = (RNSScreenNavigationContainerView *)_containerView;
+
+  id _navigationController = containerView.subviews.firstObject.nextResponder;
+  if (![_navigationController isKindOfClass:[UINavigationController class]]) {
+    return;
+  }
+
+  UINavigationController *navigationController = (UINavigationController *)_navigationController;
+  id _subviews = navigationController.view.superview.reactSubviews;
+  if (![[_subviews firstObject] isKindOfClass:[RNSScreenView class]]) {
+    return;
+  }
+  NSArray<RNSScreenView *> *screenViews = (NSArray<RNSScreenView *> *)_subviews;
+
+  if (index < 0 || index >= screenViews.count) {
+    return;
+  }
+
+  if (screenViews[index].activityState == RNSActivityStateOnTop) {
+    return;
+  }
+
+
+  [screenViews enumerateObjectsUsingBlock:^(RNSScreenView *obj, NSUInteger idx, BOOL *stop) {
+    obj.activityState = (idx == index) ? RNSActivityStateOnTop : RNSActivityStateInactive;
+  }];
+  // containerView.shouldBreakJSUpdateCount = 1;
+  UIViewController *controller = screenViews[index].controller;
+  [navigationController setViewControllers:@[controller] animated:NO];
+
+  [gesture.view.superview.subviews enumerateObjectsUsingBlock:^(__kindof UIView *obj, NSUInteger idx, BOOL *stop) {
+    NSArray<UIView *> *opacityViewList = obj.subviews;
+    if ([opacityViewList count] != 2) {
+      opacityViewList = [opacityViewList firstObject].subviews;
+      if ([opacityViewList count] != 2) {
+      	return;
+      }
+    }
+    if ((opacityViewList[0].alpha  opacityViewList[1].alpha) != 1) {
+      return;
+    }
+    if (index == idx) {
+      opacityViewList[0].alpha = 0;
+      opacityViewList[1].alpha = 1;
+    } else {
+      opacityViewList[0].alpha = 1;
+      opacityViewList[1].alpha = 0;
+    }
+  }];
+}
+
+
 - (void)didMoveToWindow
 {
+  if (self.activityState == 2) {
+    [self addGestureToTabBarItem];
+  }
   // For RN touches to work we need to instantiate and connect RCTTouchHandler. This only applies
   // for screens that aren't mounted under RCTRootView e.g., modals that are mounted directly to
   // root application window.
@@ -673,12 +753,12 @@ - (BOOL)hasHeaderConfig
   return _config != nil;
 }
 
-+ (react::ComponentDescriptorProvider)componentDescriptorProvider
+ (react::ComponentDescriptorProvider)componentDescriptorProvider
 {
   return react::concreteComponentDescriptorProvider<react::RNSScreenComponentDescriptor>();
 }
 
-+ (BOOL)shouldBeRecycled
+ (BOOL)shouldBeRecycled
 {
   return NO;
 }
@@ -1010,7 +1090,7 @@ - (void)viewDidLayoutSubviews
   // The below code makes the screen view adapt dimensions provided by the system. We take these
   // into account only when the view is mounted under RNSNavigationController in which case system
   // provides additional padding to account for possible header, and in the case when screen is
-  // shown as a native modal, as the final dimensions of the modal on iOS 12+ are shorter than the
+  // shown as a native modal, as the final dimensions of the modal on iOS 12 are shorter than the
   // screen size
   BOOL isDisplayedWithinUINavController = [self.parentViewController isKindOfClass:[RNSNavigationController class]];
 
@@ -1113,7 +1193,7 @@ - (CGFloat)calculateHeaderHeightIsModal:(BOOL)isModal
   CGFloat navbarInset = 0;
 #endif // !TARGET_OS_TV
 
-  return navbarHeight + navbarInset;
+  return navbarHeight  navbarInset;
 }
 
 - (void)calculateAndNotifyHeaderHeightChangeIsModal:(BOOL)isModal
@@ -1507,7 +1587,7 @@ - (UIView *)view
 }
 #endif
 
-+ (BOOL)requiresMainQueueSetup
+ (BOOL)requiresMainQueueSetup
 {
   // Returning NO here despite the fact some initialization in -init method dispatches tasks
   // on main queue, because the comments in RN source code states that modules which return YES
@@ -1600,7 +1680,7 @@ @implementation RCTConvert (RNSScreen)
     RNSScreenDetentTypeAll,
     integerValue)
 
-+ (UIInterfaceOrientationMask)UIInterfaceOrientationMask:(id)json
+ (UIInterfaceOrientationMask)UIInterfaceOrientationMask:(id)json
 {
   json = [self NSString:json];
   if ([json isEqualToString:@"default"]) {
diff --git a/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.h b/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.h
index defd0d5..72eb79d 100644
--- a/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.h
+++ b/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.h
@@ -8,6 +8,7 @@
 @end
 
 @interface RNSScreenNavigationContainerView : RNSScreenContainerView
+@property (nonatomic, assign) NSInteger shouldBreakJSUpdateCount;
 
 @end
 
diff --git a/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.mm b/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.mm
index f10671e..b295193 100644
--- a/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.mm
+++ b/node_modules/react-native-screens/ios/RNSScreenNavigationContainer.mm
@@ -29,7 +29,12 @@ - (void)updateContainer
     if (screen.activityState == RNSActivityStateOnTop) {
       // there should never be more than one screen with `RNSActivityStateOnTop`
       // since this component should be used for `tabs` and `drawer` navigators
-      [(RNSContainerNavigationController *)self.controller setViewControllers:@[ screen.controller ] animated:NO];
+      // [(RNSContainerNavigationController *)self.controller setViewControllers:@[ screen.controller ] animated:NO];
+      if (self.shouldBreakJSUpdateCount > 0) {
+        self.shouldBreakJSUpdateCount = 0;
+      } else {
+        [(RNSContainerNavigationController *)self.controller setViewControllers:@[ screen.controller ] animated:NO];
+      }
       [screen notifyFinishTransitioning];
     }
   }
@@ -39,7 +44,7 @@ - (void)updateContainer
 
 #pragma mark-- Fabric specific
 #ifdef RCT_NEW_ARCH_ENABLED
-+ (react::ComponentDescriptorProvider)componentDescriptorProvider
+ (react::ComponentDescriptorProvider)componentDescriptorProvider
 {
   return react::concreteComponentDescriptorProvider<react::RNSScreenNavigationContainerComponentDescriptor>();
 }
diff --git a/node_modules/react-native-screens/ios/RNSScreenStack.mm b/node_modules/react-native-screens/ios/RNSScreenStack.mm
index ea27b03..7e9e417 100644
--- a/node_modules/react-native-screens/ios/RNSScreenStack.mm
+++ b/node_modules/react-native-screens/ios/RNSScreenStack.mm
@@ -741,6 +741,12 @@ - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
   // RNSPanGestureRecognizer will receive events iff topScreen.fullScreenSwipeEnabled == YES;
   // Events are filtered in gestureRecognizer:shouldReceivePressOrTouchEvent: method
   if ([gestureRecognizer isKindOfClass:[RNSPanGestureRecognizer class]]) {
+    // We cannot only simply filter this `fullScreenSwipe` gesture by `location + gestureResponseDistance`, so we also need to rely on `swipeDirection + translationInView`.
+    RNSPanGestureRecognizer *panGestureRecognizer = (RNSPanGestureRecognizer *)gestureRecognizer;
+    CGPoint translation = [panGestureRecognizer translationInView:panGestureRecognizer.view];
+    if (((abs(translation.x) - abs(translation.y)) * (topScreen.swipeDirection == RNSScreenSwipeDirectionHorizontal ? 1 : -1)) <= 0) {
+      return NO;
+    }
     if ([self isInGestureResponseDistance:gestureRecognizer topScreen:topScreen]) {
       _isFullWidthSwiping = YES;
       [self cancelTouchesInParent];
diff --git a/node_modules/react-native-screens/ios/RNSScreenStackAnimator.mm b/node_modules/react-native-screens/ios/RNSScreenStackAnimator.mm
index abb2cf6..a886ea3 100644
--- a/node_modules/react-native-screens/ios/RNSScreenStackAnimator.mm
+++ b/node_modules/react-native-screens/ios/RNSScreenStackAnimator.mm
@@ -128,22 +128,33 @@ - (void)animateSimplePushWithShadowEnabled:(BOOL)shadowEnabled
       shadowView.alpha = 0.0;
     }
 
-    [UIView animateWithDuration:[self transitionDuration:transitionContext]
-        animations:^{
-          fromViewController.view.transform = leftTransform;
-          toViewController.view.transform = CGAffineTransformIdentity;
-          if (shadowView) {
-            shadowView.alpha = RNSShadowViewMaxAlpha;
-          }
-        }
-        completion:^(BOOL finished) {
-          if (shadowView) {
-            [shadowView removeFromSuperview];
-          }
-          fromViewController.view.transform = CGAffineTransformIdentity;
-          toViewController.view.transform = CGAffineTransformIdentity;
-          [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
-        }];
+    // [UIView animateWithDuration:[self transitionDuration:transitionContext]
+    //     animations:^{
+    //       fromViewController.view.transform = leftTransform;
+    //       toViewController.view.transform = CGAffineTransformIdentity;
+    //       if (shadowView) {
+    //         shadowView.alpha = RNSShadowViewMaxAlpha;
+    //       }
+    //     }
+    //     completion:^(BOOL finished) {
+    //       if (shadowView) {
+    //         [shadowView removeFromSuperview];
+    //       }
+    //       fromViewController.view.transform = CGAffineTransformIdentity;
+    //       toViewController.view.transform = CGAffineTransformIdentity;
+    //       [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
+    //     }];
+    UIViewPropertyAnimator *modalAnimator = [[UIViewPropertyAnimator alloc] initWithDuration:[self transitionDuration:transitionContext] timingParameters:[[UISpringTimingParameters alloc] initWithMass:3 stiffness:1000 damping:500 initialVelocity:CGVectorMake(0, 0)]];
+    [modalAnimator addAnimations:^{
+      fromViewController.view.transform = CGAffineTransformIdentity;
+      toViewController.view.transform = CGAffineTransformIdentity;
+    }];
+    [modalAnimator addCompletion:^(UIViewAnimatingPosition finalPosition) {
+      fromViewController.view.transform = CGAffineTransformIdentity;
+      toViewController.view.transform = CGAffineTransformIdentity;
+      [transitionContext completeTransition:![transitionContext transitionWasCancelled]];
+    }];
+    [modalAnimator startAnimation];
   } else if (_operation == UINavigationControllerOperationPop) {
     toViewController.view.transform = leftTransform;
     [[transitionContext containerView] insertSubview:toViewController.view belowSubview:fromViewController.view];
@@ -411,7 +422,7 @@ - (void)animateWithNoAnimation:(id<UIViewControllerContextTransitioning>)transit
   }
 }
 
-+ (BOOL)isCustomAnimation:(RNSScreenStackAnimation)animation
+ (BOOL)isCustomAnimation:(RNSScreenStackAnimation)animation
 {
   return (animation != RNSScreenStackAnimationFlip && animation != RNSScreenStackAnimationDefault);
 }
diff --git a/node_modules/react-native-screens/ios/RNSScreenStackHeaderConfig.mm b/node_modules/react-native-screens/ios/RNSScreenStackHeaderConfig.mm
index de7f368..90647c4 100644
--- a/node_modules/react-native-screens/ios/RNSScreenStackHeaderConfig.mm
+++ b/node_modules/react-native-screens/ios/RNSScreenStackHeaderConfig.mm
@@ -2,13 +2,13 @@
 #import <React/RCTConversions.h>
 #import <React/RCTFabricComponentsPlugins.h>
 #import <React/RCTImageComponentView.h>
-#import <React/UIView+React.h>
+#import <React/UIViewReact.h>
 #import <react/renderer/components/image/ImageProps.h>
 #import <react/renderer/components/rnscreens/ComponentDescriptors.h>
 #import <react/renderer/components/rnscreens/EventEmitters.h>
 #import <react/renderer/components/rnscreens/Props.h>
 #import <react/renderer/components/rnscreens/RCTComponentViewHelpers.h>
-#import "RCTImageComponentView+RNSScreenStackHeaderConfig.h"
+#import "RCTImageComponentViewRNSScreenStackHeaderConfig.h"
 #else
 #import <React/RCTImageView.h>
 #import <React/RCTShadowView.h>
@@ -43,7 +43,7 @@ @interface RCTImageLoader (Private)
 
 @implementation NSString (RNSStringUtil)
 
-+ (BOOL)RNSisBlank:(NSString *)string
+ (BOOL)RNSisBlank:(NSString *)string
 {
   if (string == nil) {
     return YES;
@@ -147,7 +147,8 @@ - (void)updateViewControllerIfNeeded
   BOOL isInFullScreenModal = nav == nil && _screenView.stackPresentation == RNSScreenStackPresentationFullScreenModal;
   // if nav is nil, it means we can be in a fullScreen modal, so there is no nextVC, but we still want to update
   if (vc != nil && (nextVC == vc || isInFullScreenModal || isPresentingVC)) {
-    [RNSScreenStackHeaderConfig updateViewController:self.screenView.controller withConfig:self animated:YES];
+    // [RNSScreenStackHeaderConfig updateViewController:self.screenView.controller withConfig:self animated:YES];
+    [RNSScreenStackHeaderConfig updateViewController:self.screenView.controller withConfig:self animated:NO];
     // As the header might have change in `updateViewController` we need to ensure that header height
     // returned by the `onHeaderHeightChange` event is correct.
     [self.screenView.controller calculateAndNotifyHeaderHeightChangeIsModal:NO];
@@ -164,7 +165,7 @@ - (void)layoutNavigationControllerView
   [navctr.view setNeedsLayout];
 }
 
-+ (void)setAnimatedConfig:(UIViewController *)vc withConfig:(RNSScreenStackHeaderConfig *)config
+ (void)setAnimatedConfig:(UIViewController *)vc withConfig:(RNSScreenStackHeaderConfig *)config
 {
   UINavigationBar *navbar = ((UINavigationController *)vc.parentViewController).navigationBar;
   // It is workaround for loading custom back icon when transitioning from a screen without header to the screen which
@@ -259,7 +260,7 @@ + (void)setAnimatedConfig:(UIViewController *)vc withConfig:(RNSScreenStackHeade
   }
 }
 
-+ (void)setTitleAttibutes:(NSDictionary *)attrs forButton:(UIBarButtonItem *)button
+ (void)setTitleAttibutes:(NSDictionary *)attrs forButton:(UIBarButtonItem *)button
 {
   [button setTitleTextAttributes:attrs forState:UIControlStateNormal];
   [button setTitleTextAttributes:attrs forState:UIControlStateHighlighted];
@@ -268,7 +269,7 @@ + (void)setTitleAttibutes:(NSDictionary *)attrs forButton:(UIBarButtonItem *)but
   [button setTitleTextAttributes:attrs forState:UIControlStateFocused];
 }
 
-+ (UIImage *)loadBackButtonImageInViewController:(UIViewController *)vc withConfig:(RNSScreenStackHeaderConfig *)config
+ (UIImage *)loadBackButtonImageInViewController:(UIViewController *)vc withConfig:(RNSScreenStackHeaderConfig *)config
 {
   BOOL hasBackButtonImage = NO;
   for (RNSScreenStackHeaderSubview *subview in config.reactSubviews) {
@@ -352,7 +353,7 @@ + (UIImage *)loadBackButtonImageInViewController:(UIViewController *)vc withConf
   return nil;
 }
 
-+ (void)willShowViewController:(UIViewController *)vc
+ (void)willShowViewController:(UIViewController *)vc
                       animated:(BOOL)animated
                     withConfig:(RNSScreenStackHeaderConfig *)config
 {
@@ -366,7 +367,7 @@ + (void)willShowViewController:(UIViewController *)vc
 
 #if defined(__IPHONE_OS_VERSION_MAX_ALLOWED) && defined(__IPHONE_13_0) && \
     __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_13_0
-+ (UINavigationBarAppearance *)buildAppearance:(UIViewController *)vc
+ (UINavigationBarAppearance *)buildAppearance:(UIViewController *)vc
                                     withConfig:(RNSScreenStackHeaderConfig *)config API_AVAILABLE(ios(13.0))
 {
   UINavigationBarAppearance *appearance = [UINavigationBarAppearance new];
@@ -461,7 +462,7 @@ + (UINavigationBarAppearance *)buildAppearance:(UIViewController *)vc
 }
 #endif // Check for >= iOS 13.0
 
-+ (void)updateViewController:(UIViewController *)vc
+ (void)updateViewController:(UIViewController *)vc
                   withConfig:(RNSScreenStackHeaderConfig *)config
                     animated:(BOOL)animated
 {
@@ -482,7 +483,22 @@ + (void)updateViewController:(UIViewController *)vc
   if (!shouldHide && !config.translucent) {
     // when nav bar is not translucent we chage edgesForExtendedLayout to avoid system laying out
     // the screen underneath navigation controllers
-    vc.edgesForExtendedLayout = UIRectEdgeNone;
+    // vc.edgesForExtendedLayout = UIRectEdgeNone;
+    // When using hideWhenScrolling, we cannot set UIRectEdgeNone as it leads to significant gesture lag and conflicts
+    __block BOOL shouldResetExtendedLayout = true;
+    [config.reactSubviews enumerateObjectsUsingBlock:^(UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
+      UIView *view = [obj.subviews firstObject];
+      if (![view isKindOfClass:[RNSSearchBar class]]) {
+        return;
+      }
+      RNSSearchBar *searchBar = (RNSSearchBar *)view;
+      if (searchBar.hideWhenScrolling) {
+        shouldResetExtendedLayout = false;
+      }
+    }];
+    if (shouldResetExtendedLayout) {
+      vc.edgesForExtendedLayout = UIRectEdgeNone;
+    }
   } else {
     // system default is UIRectEdgeAll
     vc.edgesForExtendedLayout = UIRectEdgeAll;
@@ -771,7 +787,7 @@ - (void)replaceNavigationBarViewsWithSnapshotOfSubview:(RNSScreenStackHeaderSubv
   UIView *snapshot = [childComponentView snapshotViewAfterScreenUpdates:NO];
 
   // This code should be kept in sync with analogous switch statement in
-  // `+ [RNSScreenStackHeaderConfig updateViewController: withConfig: animated:]` method.
+  // ` [RNSScreenStackHeaderConfig updateViewController: withConfig: animated:]` method.
   switch (childComponentView.type) {
     case RNSScreenStackHeaderSubviewTypeLeft:
       navitem.leftBarButtonItem.customView = snapshot;
@@ -808,10 +824,10 @@ static RCTResizeMode resizeModeFromCppEquiv(react::ImageResizeMode resizeMode)
 }
 
 /**
- * Fabric implementation of helper method for +loadBackButtonImageInViewController:withConfig:
+ * Fabric implementation of helper method for loadBackButtonImageInViewController:withConfig:
  * There is corresponding Paper implementation (with different parameter type) in Paper specific section.
  */
-+ (RCTImageSource *)imageSourceFromImageView:(RCTImageComponentView *)view
+ (RCTImageSource *)imageSourceFromImageView:(RCTImageComponentView *)view
 {
   const auto &imageProps = *std::static_pointer_cast<const react::ImageProps>(view.props);
   react::ImageSource cppImageSource = imageProps.sources.at(0);
@@ -839,7 +855,7 @@ - (NSNumber *)getFontSizePropValue:(int)value
   return nil;
 }
 
-+ (react::ComponentDescriptorProvider)componentDescriptorProvider
+ (react::ComponentDescriptorProvider)componentDescriptorProvider
 {
   return react::concreteComponentDescriptorProvider<react::RNSScreenStackHeaderConfigComponentDescriptor>();
 }
@@ -932,10 +948,10 @@ - (void)didSetProps:(NSArray<NSString *> *)changedProps
 }
 
 /**
- * Paper implementation of helper method for +loadBackButtonImageInViewController:withConfig:
+ * Paper implementation of helper method for loadBackButtonImageInViewController:withConfig:
  * There is corresponding Fabric implementation (with different parameter type) in Fabric specific section.
  */
-+ (RCTImageSource *)imageSourceFromImageView:(RCTImageView *)view
+ (RCTImageSource *)imageSourceFromImageView:(RCTImageView *)view
 {
   return view.imageSources[0];
 }
@@ -991,7 +1007,7 @@ - (UIView *)view
 
 @implementation RCTConvert (RNSScreenStackHeader)
 
-+ (NSMutableDictionary *)blurEffectsForIOSVersion
+ (NSMutableDictionary *)blurEffectsForIOSVersion
 {
   NSMutableDictionary *blurEffects = [NSMutableDictionary new];
   [blurEffects addEntriesFromDictionary:@{
diff --git a/node_modules/react-native-screens/ios/UIWindow+RNScreens.mm b/node_modules/react-native-screens/ios/UIWindow+RNScreens.mm
index e295dcc..8f78dd6 100644
--- a/node_modules/react-native-screens/ios/UIWindow+RNScreens.mm
+++ b/node_modules/react-native-screens/ios/UIWindow+RNScreens.mm
@@ -1,11 +1,22 @@
 #import "RNSFullWindowOverlay.h"
-#import "UIWindow+RNScreens.h"
+#import "UIWindowRNScreens.h"
+#import <React/RCTUtils.h>
 
 @implementation UIWindow (RNScreens)
 
 - (void)didAddSubview:(UIView *)subview
 {
   if (![subview isKindOfClass:[RNSFullWindowOverlayContainer class]]) {
+    // We only bring `RNSFullWindowOverlayContainer` above the `UIModal`; we don't handle other things like `SPAlert`
+    NSString *subviewClassString = NSStringFromClass([subview class]);
+    if (![subviewClassString hasPrefix:@"UI"] && ![subviewClassString hasPrefix:@"_UI"]) {
+      return;
+    }
+
+    if ([RCTPresentedViewController() isKindOfClass:[UIAlertController class]]) {
+      return;
+    }
+
     for (UIView *view in self.subviews) {
       if ([view isKindOfClass:[RNSFullWindowOverlayContainer class]]) {
         [self bringSubviewToFront:view];
diff --git a/node_modules/react-native-screens/lib/module/components/Screen.web.js b/node_modules/react-native-screens/lib/module/components/Screen.web.js
index 04a3491..947c23c 100644
--- a/node_modules/react-native-screens/lib/module/components/Screen.web.js
+++ b/node_modules/react-native-screens/lib/module/components/Screen.web.js
@@ -7,6 +7,8 @@ export const InnerScreen = View;
 // We're using class component here because of the error from reanimated:
 // createAnimatedComponent` does not support stateless functional components; use a class component instead.
 export class NativeScreen extends React.Component {
+  // Just to help determine whether `View.setNativeProps`` can be called in `react-native-web.createAnimatedComponent`
+  setNativeProps() {}
   render() {
     let {
       active,
diff --git a/node_modules/react-native-screens/src/components/Screen.web.tsx b/node_modules/react-native-screens/src/components/Screen.web.tsx
index c624a49..9084542 100644
--- a/node_modules/react-native-screens/src/components/Screen.web.tsx
+++ b/node_modules/react-native-screens/src/components/Screen.web.tsx
@@ -9,6 +9,8 @@ export const InnerScreen = View;
 // We're using class component here because of the error from reanimated:
 // createAnimatedComponent` does not support stateless functional components; use a class component instead.
 export class NativeScreen extends React.Component<ScreenProps> {
+  // Just to help determine whether `View.setNativeProps`` can be called in `react-native-web.createAnimatedComponent`
+  setNativeProps() {}
   render(): JSX.Element {
     let {
       active,
